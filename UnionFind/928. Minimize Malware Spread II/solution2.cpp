/*
 *  參考解答 : https://leetcode.com/problems/minimize-malware-spread-ii/solutions/797615/short-c-union-find-solution-with-detailed-explanation/
 *
 *
 */
class Solution {
    int n;
    vector<int> root, rank;
    int find(int x) {
        if(root[x] == x) return x;
        else return root[x] = find(root[x]);
    }
    int un(int x, int y) {
        x = find(x), y = find(y);
        if(x == y) return 0;
        if(rank[y] > rank[x]) swap(x, y);
        root[y] = x;
        return rank[x] += rank[y];
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        n = graph.size();
        root.resize(n);
        rank.resize(n, 1);
        iota(begin(root), end(root), 0);

        // 先找出clean node
        vector<int> clean;
        unordered_set<int> initial_set(initial.begin(), initial.end());
        for (auto i = 0; i < n; i++)
            if (!initial_set.count(i)) clean.push_back(i);

        // 把clean node先連接起來
        for (auto i : clean)
            for (auto j : clean)
                if (i != j && graph[i][j]) un(i, j);

        //每個group有多少個nodes
        vector<int> area(n, 0);
        for (auto i : clean) area[find(i)]++;

        unordered_map<int, unordered_set<int>> groups_via_clan_node; // 每個被感染的node經過clean node跟那些group連結
        unordered_map<int, int> infect_count_of_group; // 每個group內有多少個被感染的nodes
        for (auto i : initial) {
            for (auto j : clean) {
                if (graph[i][j]) groups_via_clan_node[i].insert(find(j));
            }
            for (auto j : groups_via_clan_node[i])
                infect_count_of_group[j] += 1;
        }

        // Try remove each malware
        int res = initial[0], max_cnt = -1;
        for (auto& [malware, groups] : groups_via_clan_node) {
            int count = 0;
            for (auto& g : groups) {
                //只有當group中有一個malware移除才有意義
                if (infect_count_of_group[g] == 1)
                    count += area[g]; // count : 多少個clean nodes
            }
            if (count > max_cnt || (count == max_cnt && malware < res)) {
                max_cnt = count;
                res = malware;
            }
        }

        return res;
    }
};
