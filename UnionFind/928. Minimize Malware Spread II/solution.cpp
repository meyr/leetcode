/*
 *  這個方法比較暴力 
 *  1. 先得到全部感染的nodes
 *  2. 一個一個移除initial中的node 然後再得到感染的nodes
 *  3. 得到移除的node可以有最小的感染nodes
 *
 */

class UnionFind{
    vector<int> root, rank;
    int sz;
    int find(int x) {
        if(root[x] == x) return x;
        else return root[x] = find(root[x]);
    }
    int un(int x, int y) {
        x = find(x), y = find(y);
        if(x == y) return 0;
        if(rank[y] > rank[x]) swap(x, y);
        root[y] = x;
        return rank[x] += rank[y];
    }
public:
    UnionFind(vector<vector<int>>& graph, int n) {
        sz = graph.size();
        root.resize(sz);
        rank.resize(sz, 1);
        iota(begin(root), end(root), 0);
        for(int i = 0; i < sz; ++i) {
            if(i == n) continue;
            for(int j = 0; j < sz; ++j) {
                if(j == n) continue;
                if(graph[i][j]) un(i, j);
            }
        }
    }
    int getMalwareTotal(vector<int>& initial, int n) {
        int total{};
        unordered_set<int> v;
        for(auto& i : initial) {
            if(i == n) continue;
            int r = find(i);
            if(!v.count(r)) {
                total += rank[r];
                v.insert(r);
            }
        }
        return total;
    }
};
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        UnionFind uf(graph, -1);
        int ans{301}, nodes;
        nodes = uf.getMalwareTotal(initial, -1);
        for(auto& i : initial) {
            UnionFind muf(graph, i);
            int t = muf.getMalwareTotal(initial, i);
            if(nodes > t) {
                nodes = t;
                ans = i;
            } else if(nodes == t)
                ans = min(ans, i);
        } 
        return ans;       
    }
};
