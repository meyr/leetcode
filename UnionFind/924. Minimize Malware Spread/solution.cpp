/*   
 *  因為要從initial中找出最小的index 刪除這個node之後可以讓感染減到最小
 * 
 *  1. 先用union find把群組區分出來 並且得到每個群組的大小 rank
 *  2. 因為只能刪掉一個 如果被感染的node兩個以上存在同一個群組 則刪除也沒意義
 *  3. 所以選擇刪除 g[r].size() == 1 且 群組最大那一個 rank[r] > nodes
 */

class Solution {
    vector<int> root, rank;
    int find(int x) {
        if(root[x] == x) return x;
        else return root[x] = find(root[x]);
    }
    int un(int x, int y) {
        x = find(x), y = find(y);
        if(x == y) return 0;
        if(rank[y] > rank[x]) swap(x, y); //rank[x] > rank[y]
        root[y] = x;
        return rank[x] += rank[y];
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int sz = graph.size();
        root.resize(sz), iota(begin(root), end(root), 0);
        rank.resize(sz, 1);
        for(int i = 0; i < sz; ++i)
            for(int j = 0; j < sz; ++j)
                if(i != j && graph[i][j])
                    un(i, j);
        unordered_map<int, vector<int>> g; // root node, current node
        sort(begin(initial), end(initial));
        for(auto& n : initial) {
            int r = find(n);
            g[r].push_back(n);
        }

        int ans = initial[0], nodes = 0;
        for(auto& n : initial) {
            int r = root[n];
            if(g[r].size() == 1 && rank[r] > nodes) {
                ans = n;
                nodes = rank[r];
            }
        }
        return ans;        
    }
};
